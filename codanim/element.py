import math
import pickle
import time
from datetime import timedelta

import attr
from pyglet import shapes


def __no_reference_converter(value):
    if isinstance(value, Element):
        return value.copy()
    return value


def __ensure_no_references(cls, fields):
    result = [f.evolve(converter=__no_reference_converter) for f in fields]
    return result


# [2021-07-29 08:21 PM] todo - component bag metaclass that generates classes
# and caches them for a given set of properties, so that copying is essentially
# free because all objs have the same properties


# [2021-07-29 08:24 PM] todo - related to the above - or, instead of generating
# on the fly, they're generated by flattening the composition structure and
# returning objects which only have flat members, could even be dataobjects

element_dec = attr.s(
    auto_attribs=True, field_transformer=__ensure_no_references, slots=True
)


@element_dec
class Element:
    def copy(self):
        # it's faster than deepcopy and doesn't require recursing Â¯\_(ãƒ„)_/Â¯
        return pickle.loads(pickle.dumps(self))

    def but_with(self, **kwargs):
        """Return a copy of the element, but with one or more fields modified.

        Nested elements can have their fields modified by nesting with __.
        For example:

            left_circle = circle.but_with(position__x=20)

        # [2021-08-01 05:41 PM] todo - change_by (or other name):
            larger_circle = circle.change_by(radius=10)
        # [2021-08-01 05:41 PM] todo - which copies as before, but adds 10
          to the radius instead of removing it.
        """
        cpy = self.copy()

        for attribute, value in kwargs.items():
            path = attribute.split("__")

            if len(path) == 1:
                # Non-nested attribute change
                setattr(cpy, attribute, value)

            else:
                # Nested attribute change, e.g. circle__position__x=4
                *nested_attr_chain, attribute = path
                obj = cpy
                for nested_attr in nested_attr_chain:
                    obj = getattr(obj, nested_attr)
                setattr(obj, attribute, value)

        return cpy


@element_dec
class Position(Element):
    x: int
    y: int


@element_dec
class Color(Element):
    r: int
    g: int
    b: int

    # a: float = 1

    def as_tuple(self):
        return self.r, self.g, self.b


# todo remove
# @element_dec
# class MyPaint(Element):
#     anti_alias: bool
#     color: Color
#     stroke_width: int
#
#     @property
#     def as_skia_paint(self):
#         return skia.Paint(
#             AntiAlias=self.anti_alias,
#             StrokeWidth=self.stroke_width,
#             Color4f=self.color.as_skia_c4f,
#         )


# I would like to be able to say circle.pos.x += 3
# I would also like to be able to pass the same pos to something else, and have it be a copy
# maybe override __init__/new to assign to self copies of elements instead of references?


@element_dec
class Circle(Element):
    position: Position
    radius: int
    color: Color

    def add_to_batch(self, batch):
        return [
            shapes.Circle(
                self.position.x,
                self.position.y,
                self.radius,
                color=self.color.as_tuple(),
                batch=batch,
            )
        ]

    def draw(self) -> None:
        # [2021-08-02 08:35 AM] todo - maybe this should instead of directly
        # drawing return a namedtuple representing parameters for a drawnable
        # thing. Or maybe there's a set of basic drawable elements.
        print(":)")


# class DrawSystem:
#     def __init__(self):
#         cv2.namedWindow("drawyo")
#         self.surface = skia.Surface(512, 512)
#         self.canvas: skia.Canvas = self.surface.getCanvas()
#
#     def draw(self, elements):
#         self.canvas.clear(0xFF111122)
#         for element in elements:
#             element.draw(canvas=self.canvas)
#
#     def updating_display(self):
#         scene = SceneLogicThing()
#         s = time.time()
#         while True:
#             elements = scene.get_frame_for_t(dt(time.time()))
#             self.draw(elements)
#             image = self.surface.makeImageSnapshot()
#             frame = image.toarray()
#             cv2.imshow("drawyo", frame)
#             cv2.waitKey(1)
#
#             if time.time() - s > 2:
#                 return
